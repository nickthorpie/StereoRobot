# -*- coding: utf-8 -*-
"""Copy of dijkstras_algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YuY8fq4FKkntScEMeXOmV51gRvKJ281T
"""

# !pip install dijkstra

import numpy as np
from dijkstra import Graph, DijkstraSPF

A, B, C, D, E = nodes = list("ABCDE") # ("ACBDE...") MUST match the declared variables A, B, C, D, E...

# Edges refer to the connections made between each node. The distance between the two nodes
# is indicated by the third value in the brackets. The program assesses this list of nodes
# and the available connections that can be taken to get from one node to another. Once this list is compiled,
# it presents the shortest route possible.

graph = Graph()

# FROM NODE TO CONNECTION
graph.add_edge(A, B, 1) # Distance from A -> B is 1
graph.add_edge(A, C, 1)
graph.add_edge(A, D, 1)
graph.add_edge(A, E, 1)

# FROM CONNECTION TO NODE - For establishing bidirectionality 
graph.add_edge(B, A, 1)
graph.add_edge(C, A, 1)
graph.add_edge(D, A, 1)
graph.add_edge(E, A ,1)

#graph.add_edge(A, B, 7) # 1 -> 2
#graph.add_edge(A, C, 9) # 1 -> 3
#graph.add_edge(A, F, 14) # 1 -> 6
#graph.add_edge(F, A, 14) # 6 -> 1

#graph.add_edge(B, C, 10) # 2 -> 3
#graph.add_edge(B, D, 15) # 2 -> 4

#graph.add_edge(C, D, 11) # 3 -> 4
#graph.add_edge(C, F, 2) # 3 -> 6
#graph.add_edge(F, C, 2) # 6 -> 3

#graph.add_edge(D, E, 6) # 4 -> 5

#graph.add_edge(E, F, 9) # 5 -> 6
#graph.add_edge(F, E, 9) # 6 -> 5

dijkstra = DijkstraSPF(graph, A)

print("%-5s %-5s" % ("label", "distance"))
for u in nodes:
    print("%-5s %8d" % (u, dijkstra.get_distance(u)))

print(" -> ".join(dijkstra.get_path(E)))

def nav(start,end):
    print(" -> ".join(dijkstra.get_path(T)))

# This lil list thingy is useless just ignore it
EAD = [514,90]
EAC = [513,0]
EAB = [512,-90]

DAE = [415,-90]
DAB = [412,0]
DAC = [413,90]

CAD = [314,-90]
CAE = [315,0]
CAB = [312,90]

BAC = [213,-90]
BAD = [214,0]
BAE = [215,90]
#


A_con_code = ['EAD','EAC','EAB','DAE','DAB','DAC','CAD','CAE','CAB','BAC','BAD','BAE']
A_con_turn = ['right','straight','left','left','straight','right','left','straight','right','left','straight','right']

def path(start,finish):
  dijkstra = DijkstraSPF(graph,start)
  return dijkstra.get_path(finish)

qr_input = A
def checkpoint(start,finish,checkpoint):
  sequence = path(start,finish)
  position = sequence.index(checkpoint)
  if position == len(sequence):
    return 0
  else:
    turn = [sequence[position-1],sequence[position],sequence[position+1]]
    st = f"{turn[0]}{turn[1]}{turn[2]}"
    turn_id = A_con_code.index(st)
    return A_con_turn[turn_id]



if __name__ == "__main__":
    QR_OUTPUT = A
    start = D
    end = C
    ret = checkpoint(start,end,QR_OUTPUT)
    print("\n")
    print(ret)